# Hello算法
## pyhon语法补充
for _的 _作为循环变量时候不关心其具体值，只需要把循环执行range(10)次

## 复杂度分析
* 算法效率评估：实际测试局限较大，仅通过理论估算算法效率，该方法被称为渐进复杂度分析。它描述了随着输入数据大小的增加（算法运行效率与输入数据体量关系）算法执行所需时空的增长趋势（不是运行时间与占用空间具体指，而是时空增长快慢）

* 迭代（iteration）与递归（recursion）
 * 迭代：for（适合预先知道迭代次数，与n成正比，线性关系，比while更紧凑），while（比for 循环自由）
 * 递归：通过函数调用自身来解决问题；递：程序不断深入调用自身，通常传入更小或更简化参数，直到终止条件；归：触发终止条件后，程序从最深层递归函数开始逐层返回，汇聚每一层结果
 * 递归分为普通递归（在归中求和，每层返回后再执行一次求和）和尾递归（递归相连，不用保存上下文，在递中求和，归秩序层层返回），python不支持尾递归
 * 递归树：在函数内递归调用了两个函数，这意味着从一个调用产生了两个调用分支，产生一棵层数为的「递归树 recursion tree」。
 * -> int是类型注解的一部分，用于指示函数返回值的类型，这种语法不影响函数的实际运行；使用 _ 作为循环变量或在其他需要表达“这个变量不重要”场景下的占位符，只需重复代码不关心当前是循环的哪一次迭代 `for _ in range(5)`

* 时间复杂度
* 空间复杂度

## 数据结构分类
* 逻辑结构
  * 线性：数组、链表、栈、队列、哈希表，元素之间一对一
  * 非线性
    * 树形结构：树、堆、哈希表，一对多
    * 网状结构：图，多对多
* 物理结构：反映数据在计算机内存的存储方式
  * 连续空间存储：数组
  * 分散空间存储：链表
* 所有数据结构都是**基于数组（静态数据结构）、链表（动态数据结构）或二者的组合实现的**
  * 基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量等
  * 基于链表可实现：栈、队列、哈希表、树、堆、图等
* 基本数据类型提供数据的“内容类型”，而数据结构提供数据的“组织方式”

## 数组与链表
* 数组连续存储，类型相同长度不可变；链表分散存储，类型可不同占用空间大方便扩容；列表，即为动态数组（如py中list，cpp中vector）
* 数组具有更高的缓存命中率，因此它在操作效率上通常优于链表；在做算法题时，倾向于选择基于数组实现的栈；数据量非常大、动态性很高、栈的预期大小难以估计，基于链表实现的栈更合适
* 通常将头结点当作链表的代称，比如头结点为n0，链表可以记作链表n0
  * n1 = n0.next：获取链表节点的下一个节点
  * P.next = n1：修改链表结构

## 栈与队列
* 栈先入后出犹如一叠盘子（想象为一个U形框，开口是栈顶，下面是栈底），队列先入先出如同排队（想象为一个羽毛球直筒，出入方向都指向队首）；出入栈都在栈顶操作，入队在队尾，出队在队首
* 时间效率，栈的数组实现具有较高的平均效率，但在扩容时，单次入栈操作的时间复杂度会劣化至O(n)；栈的链表实现更稳定
* 在空间效率方面，栈的数组实现可能导致一定的空间浪费；链表节点所占用的内存空间比数组元素更大
* 双向队列兼顾栈与队列逻辑（peak_first/peak_last，pop push同理），自由度更高，队首队尾均可添加删除


## 哈希表
哈希表使用哈希函数将 key 映射为哈希值，然后使用这个（数值的）哈希值（或经过处理的哈希值）作为数组索引来存储或查找 value
* 哈希冲突
  * 多个输入对应相同输出，解决方法：改良哈希表使其冲突时候能正常工作（链式地址、开放寻址）、必要严重时候再哈希扩容
  * 哈希扩容：增大哈希表容量n，n大，多个key备份到同一个桶中的概率就低；哈希扩容类似数组扩容需要迁移非常耗时；引入负载因子load factor=哈希表元素数量/桶数量，用于衡量哈希冲突的严重程度，作为哈希表扩容的触发条件
  * 链式地址：单个元素转换为链表，将所有发生冲突的键值对存储在同一链表中（即每个桶一个链表），当链表很长时，可以将链表转换为avl树或红黑树
  * 开放寻址：不引入额外数据结构，通过多次探测处理哈希冲突，在哈希表中寻找下一个可用的空槽来存储该键值对，包括线性探测、平方探测和多次哈希等；不能在开放寻址哈希表中直接删除元素，使用懒删除机制解决
  * 上面的方法智能保证可以在发生冲突时候正常工作，不能减少哈希冲突的发生，注意力放到hash()设计上；使用大质数作为模数，可以最大化地保证哈希值的均匀分布

## 树
* 基本概念
  「根节点 root node」：位于二叉树顶层的节点，没有父节点
  「叶节点 leaf node」：没有子节点的节点，其两个指针均指向 None
  「边 edge」：连接两个节点的线段，即节点引用（指针）
  节点所在的「层 level」：从顶至底递增，根节点所在层为 1 
  节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 
  二叉树的「高度 height」：从根节点到最远叶节点所经过的边的数量
  节点的「深度 depth」：从根节点到该节点所经过的边的数量
  节点的「高度 height」：从距离该节点最远的叶节点到该节点所经过的边的数量

* 二叉树类型
  * 完美（perfect binary tree）二叉树：所有层的节点都被完全填满，叶节点度为0，其余都为2，若树高h，则节点总数2^(h+1)-1
  * 完全（complete）二叉树，只有底层节点未被填满，且底层节点尽量靠左填充
  * 完满（full）二叉树：除了叶节点，其余所有节点都有两个子节点（所有节点的度均为0、2）
  * 平衡（balanced）二叉树，任意节点的左子树和右子树的高度之差不超过1
  * 极端情况退化为链表

* 二叉树的遍历
  * breadth-first search：BFS，广度优先搜索，层序遍历逐层推进
  * depth-first search：DFS，深度优先，前中后序遍历，就像绕着整颗二叉树的外围走一圈（每个节点上下左右，上对应指针，左前下中右后）
  * BFS基于递归实现，递：向下递推，归：向上回溯
  
* 二叉树的数组表示
  * 层序遍历并不包含none，存在多种二叉树结构都符合该层序遍历序列，为了解决，我们可以考虑在层序遍历序列中显式写出所有none
  * 完全二叉树非常适合用数组表示，所有none一定在末尾可省略

* 二叉搜索树binary search tree：与二分法原理一致
  * 满足：对于根节点，左子树.value<根节点<右子树；其他任意节点的也是二叉搜索树，即满足前述条件
  * 二叉搜索树的中序遍历是升序的，多次插入和删除操作后，二叉搜索树可能会退化成链表，logn劣化为n

* AVL树：即是二叉搜索树，也是二叉平衡树，称为平衡二叉搜索树
  * 特点：旋转操作（保证性质），既能保持二叉搜索树的性质，也能使树重新变为平衡二叉树；通过左右旋可以使失衡树恢复（定义性质）
  
  * “节点高度”是指从该节点到它的最远叶节点的距离，即所经过的“边”的数量。叶节点的高度为 0，而空节点的高度为-1
  * 失衡节点为平衡因子f绝对值＞1的节点，f定义为节点左子树高度减去右子树高度，空节点f为0
  ![alt text](image.png)
  * 红黑树在许多应用中比 AVL 树更受欢迎，因为红黑树的平衡条件相对宽松，在红黑树中插入与删除节点所需的旋转操作相对较少，其节点增删操作的平均效率更高

## 堆heap：即优先队列，抽象结构
是满足特定条件的完全二叉树分为小顶堆min heap和大顶堆，任意节点的值分别≤≥其子节点的值，通常用于实现优先队列，大堆顶相当于元素按照从大到小的顺序出队的优先队列
top-k

## 图
较于线性关系（链表）和分治关系（树），网络关系（图）的自由度更高更复杂，常用 邻接矩阵 和邻接表表示


## 搜索
暴力搜索：通过遍历数据结构定位目标元素
自适应搜索：利用数据组织结构或数据包含的先验信息，实现高效元素查找，如二分、哈希和二叉树查找等
### 二分查找
* 基于分治策略，适用于有序数据，分双闭区间和左闭右开（较少用），仅适用于数组不适用链表，不仅适用搜索目标元素，还可解决许多变种问题
* 搜索目标元素的插入位置：无重复元素时候，包含target则插入点索引为该target索引，不包含target插入点索引为左指针i；存在重复元素时需要查找数组最左一个target索引
* 查找边界（返回数组中最左一个元素 target 的索引）：查找右边界可以复用查找左边界（最左＋1），转化为查找元素

### 哈希优化策略
* 常通过将线性查找替换为哈希查找来降低算法的时间复杂度


## 排序
1. 评价维度：运行快、原地、稳定、正向自适应、通用性好
  * 运行效率：时间复杂度尽可能低
  * 就地性：在原数组上直接操作实现排序，无需借助额外的辅助数组
  * 稳定性：完成排序后，相等元素在数组中的相对顺序不变（稳定排序是多级排序场景的必要条件）
  * 自适应性：自适应排序的时间复杂度回收输入数据的影响
  * 是否基于比较：基于比较复杂，通用性更佳
2. 选择排序：循环，每轮从未排序区间选择最小元素
3. 冒泡排序：从左端开始遍历，依次比较相邻元素大小，左＞右则交换
4. 插入排序：在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入已排序区间，该方法使用频率高于冒泡和选择，数据量较小时候更快
5. 快速排序：哨兵划分，选择某元素作为“基准数”（选三个元素中位数），将所有小于其元素移左，大于移右
6. 归并排序：基于分治，本质递归；划分阶段不断将数组从中点分开，化长为短至1，排序，合并阶段一次排序子数组，适用于链表排序
7. 堆排序：输入数组建立大顶堆，将堆顶元素（最大元素）与堆底元素交换，执行堆化操作
---
8. 桶排序：初始化k个桶，将元素均匀分配到其中，在桶内排序后合并
9. 计数排序：先找到最大数字m，建立长度为m+1（0-m+1）的辅助数组，在该数组中遍历统计个数字出现次数，输出，只适用于非负整数，数据量大但范围较小情况
10. 基数排序：初始化位数k=1，对k位执行排序，直至所有位排序完成，后会覆盖之前，但之前也有意义，适用于数值范围较大的情况，前提是数据必须可以表示为固定位数的格式，而且位数不能过大
![alt text](image-1.png)


## 分治
通常基于递归实现，如归并排序
* 使用分治方法的三个依据
  * 问题可以分解：原问题可以分解成规模更小、类似的子问题，以及能够以相同方式递归地进行划分
  * 子问题是独立的：子问题之间没有重叠，互不依赖，可以独立解决
  * 子问题的解可以合并：原问题的解通过合并子问题的解得来
* 提效原因
  * 操作数量优化，时间复杂度降低
  * 并行计算优化，有利于操作系统的并行优化
* 应用
  * 寻找最近点对，大整数乘法矩阵乘法（均是化大为小），汉诺塔问题（递归），求解逆序对（前一数字大于后构成，借助归并排序）
  * 二分查找，归并排序，快速排序，桶排序，树，堆，哈希表
---
* 分治搜索策略：二分查找和树
  * 二分查找可以基于递推（迭代）和分治（递归）实现

## 回溯
1. 基于递归，通过穷举（深度优先遍历，如树的前中后序）解决问题，暴力搜索所有可能解决方案，记录正确
2. 尝试与回退：某个状态无法继续前进或无法得到满足条件的解，会撤销上一步的选择，退回之前的状态，尝试其他选择，回退不仅仅包含函数的返回
![alt text](image-2.png)
3. 全排列问题
4. 子集和问题
5. N皇后问题


## 动态规划
1. 是一种“从底到顶”的方法：从最小子问题解开始迭代构建更大子问题的解直到得到原问题的解，动态规划并不包含回溯过程，因此只需使用循环迭代实现，无需递归（可以但效率稍低），可以使用滚动变量（滚动数组）优化
2. DP问题
3. 0-1背包问题
4. 完全背包问题
5. 编辑距离问题


## 贪心
1. 在解决问题的每个决策阶段，都选择当前看起来最优的选择
   * 性质：贪心选择性质，只有当局部最优选择始终可以导致全局最优时，贪心算法才能保证最优；最优子结构，原问题最优解包含子问题最优解
   * 解题步骤：分析状态定义优化目标和约束条件；确定贪心策略在每一步减小问题规模并最终解决问题；正确性证明：证明贪心问题的两个性质

2. 分数背包问题
3. 最大容量问题
4. 最大切分乘积问题