# 漫画算法：小灰的算法之旅
## 算法与数据结构基础
* 算法评价：时空复杂度，运行时间的长短和占用内存空间的大小，其中代码绝对执行时间难以估计，但可以预估代码**基本操作执行次数**
* 渐进时间复杂度：使用大O表示法，遵循 如果运行时间是常数量级则用表示，只保留时间函数的最高阶项，如果最高阶项存在，则省去其系数；O(n^2)>n>logn>1，考虑n取足够大时候。T(n) = O(f(n)),T为程序基本操作执行次数函数，n为输入规模
* 空间复杂度：大O表示法，S(n) = O(f(n))。常量空间为O(1)，线性空间为n，二维为n^2，递归空间为n，此处空间指的是算法分配空间（分别对应存储空间固定于输入规模无关，线性集合如列表，二维列表）
* 时间重要性＞空间
---
* data structure
  * 线性结构包括**数组、链表**及其衍生出的**栈、队列、哈希表**；
  * 树如二叉树及其衍生的二叉堆；图，多对多关系；其他衍生：跳表、哈希链表、位图
  * 不同算法会选用不同的数据结构
* 数组：顺序存储，在py中使用的是list列表和tuple元组，前者动态可扩展，后者不可变，都是对数组的封装
* 链表：随机存储，在物理上非连续，非顺序的数据结构，链表 = 若干节点node，单向链表每一node = 存放数据的变量data + 指向下一个节点的指针next；双向多一个next；其允许插入的元素是无穷无尽的，不需像数组一样考虑扩容的问题
* 数组适合读操作，链表适合写操作；二者都是数据存储的物理结构

|  | 查找 | 更新 | 插入 | 删除 |
| :---: | :--- | ---: | :--- | :---: |
| 数组 | 1 | 1 | n | n |
| 链表 | n | 1 | 1 | 1 |

* **逻辑结构分线性（顺序表、栈、队列）和非线性（树、图）结构，物理结构分为顺序存储（数组）和链式存储（链表）结构**
* 栈：线性数据结构，元素先入后出FILO，**最早放元素存放的位置叫栈底bottom**，最后进入的元素存放位置叫栈顶top；常见操作入栈push，出栈pop，相当于python的append和pop
* 队列：先入先出FIFO，队头front队尾rear，与栈一样都可用数组或者队列实现；入队enquue，出队dequeue，相当于py中collections.deque，queue.Queue
* 栈、队列的应用：输入输出顺序相反，用于对**历史的回溯**，可以代替递归逻辑，面包屑导航（网页翻到前一面）；队列输入输出顺序相同，用于对**历史的回放**
* 哈希表：也叫散列表，提供了键key和值value，本质上是一个数组，key与数组下标中转的函数叫做哈希函数，在py中对应字典dict

## 树与排序
### 树
* 定义：是n≥0个节点的有限集。当n = 0时为空树。具备特点1.有且仅有一个根节点2.n＞1时，其余节点可分为m＞0个互不相交的有限集，每一个集合本身又是一个数，并称为根的子树
* 根节点，叶子节点， 父节点，孩子节点，兄弟节点
* 使用链式存储结构和数组结构表达，链式存储最直观，一个节点最多可指向两个孩子节点，所以包含三部分，存储数据的data变量，指向左孩子的left指针，指向右孩子的left指针；数组存储的话按层级顺序把节点放到数组中对应位置上，空缺则空缺，这样可以放方便定位二叉树父子节点关系，但对于一个稀疏二叉树，用数组表示非常浪费空间
---
* 应用：进行查找操作，维持相对顺序；查找操作：使用二叉查找树（若左子树不为空，则左子树所有节点的值均＜根节点的值，若右子树不为空，则右子树所有节点的值均＞根节点的值，左子树、右子树也均为二叉查找树），类似二分法；维持顺序：二叉查找树又叫二叉排序树，可以保证有序性，但涉及到一个自平衡的问题，二叉树变成坡脚
* 二叉树的遍历：介绍数组、链表时候未详细介绍遍历，因为遍历本身是个线性操作，所以同样遍历具有线性结构的数组或链表，是一个轻而易举的事，而二叉树是一个非线性数据结构，分为深度优先遍历（前中后序遍历）和广度优先遍历（层序遍历），树的遍历常常使用递归实现（结构天然合适）
* **补充**：对于重复性问题（遍历），递归是通过函数调用自身来解决且代码量少但会占用栈空间可能溢出，而迭代是通过循环结构反复执行一段代码来解决
---
* 二叉堆：本质上是一种完全二叉树，可以通过自身调整，是max/min元素移动到顶点
* 分为最大堆和最小堆，任何一个父节点的值都≥和≤它左孩子或右孩子的值，堆的插入删除节点、构建二叉堆都是基于对的自我调整
* 应用：二叉堆是实现堆排序及优先队列的基础
* 优先队列：最大/小优先队列，无论入队顺序如何，都是当前最大/小元素优先出队

### 排序算法
* 稳定排序和不稳定排序，根据值相同的元素在排序后是否仍保持排序前的顺序，大多数场景无所谓
* 冒泡排序：交换排序，稳定排序，每一轮从左到右比较元素进行单项位置交换，可多步优化去掉重复步骤，可升级为鸡尾酒排序（元素比较和交换是双向的），可以减少排序回合数但代码数量增加
* 快速排序：交换排序，分治法，每一轮挑选基准元素，比他大到一边，比他小到另一边，元素交换采用双边循环和单边循环，在该过程中使用递归，可用栈代替，**绝大多数的递归逻辑都可以用栈代替**
* 堆排序：无序数组-二叉堆-循环删除对顶元素，替换到二叉堆末尾，调整堆产生新的堆顶
* 计数排序和桶排序：可以达到线性复杂度，不基于元素比较，计数排序适用于整数排序、取值范围不大时统计出现次数可优化；桶排序划分区间，适用于元素分布均匀情况，可对小数